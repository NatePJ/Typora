## this

> 当一个对象创建后，Java虚拟机（JVM）就会给这个对象分配一个引用自身的指针，这个指针的名字就是 this。
>
> 因此，this只能在类中的非静态方法中使用，静态方法和静态的代码块中绝对不能出现this，并且this只和特定的对象关联，而不和类关联，同一个类的不同对象有不同的this。

#### **1、** 使用this来区分当前对象

Java中为解决变量的命名冲突和不确定性问题，引入关键字this代表其所在方法的当前对象的引用：

1)  构造方法中指该构造器所创建的新对象；

2)  方法中指调用该方法的对象；

3)  在类本身的方法或构造器中引用该类的实例变量（全局变量）和方法。

​     this只能用在构造器或者方法中，用于获得调用当前的构造器方法的对象引用。可以和任何的对象引用一样来处理这个this对象。

说明：

（1）当实例变量和局部变量重名，JAVA平台会按照先局部变量、后实例变量的顺序寻找。即，方法中使用到的变量的寻找规律是先找局部变量，再找实例变量。如果没用找到，将会有一个编译错误而无法通过编译。

（2）如果使用this.a，则不会在方法（局部变量）中寻找变量a,而是直接去实例变量中去寻找，如果寻找不到，则会有一个编译错误。

（3）在一个方法内，如果没有出现局部变量和实例变量重名的情况下，是否使用this关键字是没有区别的。

（4）在同一个类中，Java普通方法的互相调用可以省略this+点号，而直接使用方法名+参数。因为Java编译器会帮我们加上。

#### **2、** 在构造器中使用this来调用对象本身的其他构造器

在构造器中使用this（[args_list]）；可以调用对象本身的其他的构造器。直接使用this()加上类构造器所需要的参数。就可以调用类本身的其他构造器了。如果类中有多个其他构造器定义，系统将自动根据this()中的参数个数和类型来找出类中相匹配的构造器。

注意： 在构造器中可以通过this()方式来调用其他的构造器。但在一个构造器中最多只能调用一个其他的构造器。并且，对其他构造器的调用动作必须放在构造器的起始处（也就是构造器的==首行==），否则编译的时候将会出现错误，另外不能在构造器以外的地方以这种方式调用构造器。

#### **3、** this关键字还有一个重大的作用就是返回类的引用。如在代码中，可以使用return this来返回某个类的引用。此时，这个this关键字就代表类的名称



## super

- 调用父类的属性和方法
- 调用父类的构造器，必须在子类构造器的第一行。
- 只能出现在子类的方法和构造方法中
- super和this不能同时调用构造器，因为两个都必须在第一行
- this没有继承也能使用，super只能在子类继承使用
- 不同
  - this本身调用者对象
  - 代表父类对象引用
- **子类构造器默认第一行调用父类==无参==构造器，且可以省略，如果父类没有无参构造器，则子类构造器定义不能省略第一行的调用，如下代码**

```java
public class People {
    private int a;
//    public People() {
//        System.out.println("父类构造器无参");
//    }
    public People(int a){
        this.a=a;
        System.out.println("父类构造器有参");
    }
}
```

```java
public class Student extends People{

    public Student() {
        super(1);//父类无无参构造器，子类不能省略此行，以调用定义的有参构造器
        System.out.println("子类构造器无参");
    }
    public Student(int a) {
        super(1);
        System.out.println("子类构造器有参");
    }

}
```

